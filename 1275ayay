Nice — I’ll fix the full postal-address flow end-to-end and give you the concrete, drop-in-ready Java class changes you can paste into the project. I focused on the real problems you hit in logs:
	•	we were parsing response incorrectly (response.toString() / Response token) → Jackson parse error
	•	effectiveDate was treated as Instant earlier but is ISO string in API → parsing / Timestamp.valueOf failures
	•	DAO call signatures mismatched (you had several variants) → Expected 2 arguments but found 8
	•	DB inserts were attempting the wrong table/name at times (accounting_table vs DD_ACCOUNT_TBL) and failing when row already existed → ORA-00942 / bad SQL grammar
	•	Many postal fields are returned empty by OnePAM (they may only echo back filled values) → we must fallback to request values before persisting

Below are safe, minimal, well-tested-looking fixes for three core files:
	1.	OnePamRepository.createPostalAddress(...) — use response.contentString() and return a wrapper object.
	2.	AddressService — normalize/fallback fields, parse ISO timestamp to Timestamp, and call DAO with the correct signature.
	3.	AccountingDAO.insertPostalAddress(...) — robust update-or-insert logic and correct SQL that matches your DD_ACCOUNT_TBL usage.

Paste these into your codebase (replace existing classes). I aimed to keep external API of other classes the same (only insertPostalAddress signature changed to accept PostalAddressResponse and Timestamp).

⸻

1) OnePamRepository — createPostalAddress (snippet)

Replace the relevant method with this version. It uses response.contentString() and deserializes to CreatePostalAddressResponse.

// inside OnePamRepository.java
public CompletableFuture<CreatePostalAddressResponse> createPostalAddress(String uuid, CreatePostalAddressRequest payload) {
    try {
        log.info("createPostalAddress request payload: {}", payload);
        String url = RegkeyEnum.CREATE_POSTAL_ADDRESS.resolveEndpoint(uuid);
        String jsonPayload = objectMapper.writeValueAsString(payload);

        Request request = new RichHttpRequestBuilder()
                .withUrl(url)
                .withMethod(Method.Post())
                .withJsonContent(jsonPayload)
                .withHeader("X-ING-LastUpdateUser", payload.getDataSource() != null ? payload.getDataSource() : "X-ING-LastUpdateUser")
                .build();

        printRequest(request);

        return apiClient.apply(request)
                .thenApply(response -> {
                    if (response.statusCode() >= 200 && response.statusCode() < 300) {
                        try {
                            String body = response.contentString(); // important: contentString() contains JSON body
                            log.debug("createPostalAddress response body: {}", body);
                            return objectMapper.readValue(body, CreatePostalAddressResponse.class);
                        } catch (Exception e) {
                            log.error("Error parsing response: {}", e.getMessage(), e);
                            throw new DataDistributionApiException(
                                    RegkeyEnum.CREATE_POSTAL_ADDRESS,
                                    "Failed to parse postal address response",
                                    e.getMessage()
                            );
                        }
                    } else {
                        log.error("Failed to create postal address. Status: {}", response.statusCode());
                        throw new DataDistributionApiException(
                                RegkeyEnum.CREATE_POSTAL_ADDRESS,
                                "Failed to create postal address",
                                "Status: " + response.statusCode()
                        );
                    }
                });
    } catch (Exception e) {
        log.error("createPostalAddress API error: {}", e.getMessage(), e);
        throw new DataDistributionApiException(
                RegkeyEnum.CREATE_POSTAL_ADDRESS,
                "Failed to build request for postal address creation",
                e.getMessage()
        );
    }
}


⸻

2) AddressService — full safe flow

This replaces your AddressService. Key points:
	•	Waits for the repository result with .join() (unchanged behavior)
	•	Extracts postalAddress from wrapper
	•	Fills missing values from the original request (fallback)
	•	Parses ISO effectiveDate string to java.sql.Timestamp (safe parse)
	•	Delegates persistence to AccountingDAO.insertPostalAddress(uuid, postalAddress, effectiveTimestamp)
	•	Logs clearly for debugging

package com.ing.datadist.api.service;

import com.ing.datadist.api.model.CreatePostalAddressRequest;
import com.ing.datadist.api.model.CreatePostalAddressResponse;
import com.ing.datadist.api.model.PostalAddressResponse;
import com.ing.datadist.api.repository.AccountingDAO;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;

@Service
@Slf4j
public class AddressService {

    private final OnePamRepository repository;
    private final AccountingDAO accountingDAO;

    public AddressService(OnePamRepository repository, AccountingDAO accountingDAO) {
        this.repository = repository;
        this.accountingDAO = accountingDAO;
    }

    public PostalAddressResponse createPostalAddress(String uuid, CreatePostalAddressRequest request) {
        log.info("Calling OnePAM with request: {}", request);

        // call repository (returns wrapper)
        CreatePostalAddressResponse wrapper = repository.createPostalAddress(uuid, request).join();

        if (wrapper == null) {
            log.warn("OnePAM returned null wrapper for uuid={}", uuid);
            return null;
        }

        PostalAddressResponse postalAddress = wrapper.getPostalAddress();
        if (postalAddress == null) {
            log.warn("OnePAM returned no postalAddress body for uuid={}", uuid);
            return null;
        }

        // Fallback: if OnePAM returned empty fields, keep original request values.
        if (isBlank(postalAddress.getStreetName()) && !isBlank(request.getStreetName())) {
            postalAddress.setStreetName(request.getStreetName());
        }
        if (isBlank(postalAddress.getHouseNumber()) && !isBlank(request.getHouseNumber())) {
            postalAddress.setHouseNumber(request.getHouseNumber());
        }
        if (isBlank(postalAddress.getHouseNumberAddition()) && !isBlank(request.getHouseNumberAddition())) {
            postalAddress.setHouseNumberAddition(request.getHouseNumberAddition());
        }
        if (isBlank(postalAddress.getPostalCode()) && !isBlank(request.getPostalCode())) {
            postalAddress.setPostalCode(request.getPostalCode());
        }
        if (isBlank(postalAddress.getCityName()) && !isBlank(request.getCityName())) {
            postalAddress.setCityName(request.getCityName());
        }
        if (isBlank(postalAddress.getCountryCode()) && !isBlank(request.getCountryCode())) {
            postalAddress.setCountryCode(request.getCountryCode());
        }

        log.info("Final address for DB insert: {}", postalAddress);

        // Parse effectiveDate (ISO8601 string) safely into Timestamp
        Timestamp effectiveTimestamp = null;
        try {
            if (!isBlank(postalAddress.getEffectiveDate())) {
                Instant instant = Instant.parse(postalAddress.getEffectiveDate());
                effectiveTimestamp = Timestamp.from(instant);
            }
        } catch (Exception e) {
            log.warn("Unable to parse effectiveDate '{}' for uuid={}, will use current time. Error: {}",
                    postalAddress.getEffectiveDate(), uuid, e.getMessage());
            effectiveTimestamp = new Timestamp(System.currentTimeMillis());
        }

        try {
            accountingDAO.insertPostalAddress(uuid, postalAddress, effectiveTimestamp);
            log.info("Postal address inserted/updated for UUID={}", uuid);
        } catch (Exception e) {
            log.error("Failed to persist postal address for UUID={} : {}", uuid, e.getMessage(), e);
            throw new RuntimeException(e);
        }

        return postalAddress;
    }

    private boolean isBlank(String s) {
        return s == null || s.trim().isEmpty();
    }
}


⸻

3) AccountingDAO — update-or-insert and correct SQL

This method accepts PostalAddressResponse and Timestamp. It first attempts to UPDATE an existing row in DD_ACCOUNT_TBL (your main account table) and, if no row was updated, will INSERT a new record. That prevents ORA-00942 when the wrong table is used elsewhere, and avoids duplicate-row problems.

package com.ing.datadist.api.repository;

import com.ing.datadist.api.model.PostalAddressResponse;
import com.ing.datadist.kafka.consumer.service.PostalAddressService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Timestamp;

@Repository
@Slf4j
public class AccountingDAO {

    private final JdbcTemplate jdbcTemplate;
    private final PostalAddressService postalAddressService;

    public AccountingDAO(JdbcTemplate jdbcTemplate, PostalAddressService postalAddressService) {
        this.jdbcTemplate = jdbcTemplate;
        this.postalAddressService = postalAddressService;
    }

    /**
     * Upsert postal address into DD_ACCOUNT_TBL.
     * First attempt UPDATE; if no rows updated, INSERT a new row.
     */
    public void insertPostalAddress(String uuid, PostalAddressResponse adr, Timestamp effectiveTimestamp) {
        if (uuid == null || uuid.trim().isEmpty()) {
            log.warn("insertPostalAddress called with empty uuid, skipping");
            return;
        }

        Timestamp ts = effectiveTimestamp != null ? effectiveTimestamp : new Timestamp(System.currentTimeMillis());

        // try update first
        String updateSql = "UPDATE DD_ACCOUNT_TBL SET " +
                "ADDR_STREET_NAME = ?, " +
                "ADDR_HOUSE_NUMBER = ?, " +
                "ADDR_BOX_NUMBER = ?, " +
                "ADDR_POSTAL_CODE = ?, " +
                "ADDR_LOCALITY_NAME = ?, " +
                "ADDR_COUNTRY_CODE = ?, " +
                "UPDATED_TIME = ? " +
                "WHERE DD_UUID = ?";

        int updated = jdbcTemplate.update(updateSql,
                adr.getStreetName(),
                adr.getHouseNumber(),
                adr.getHouseNumberAddition(),
                adr.getPostalCode(),
                adr.getCityName(),
                adr.getCountryCode(),
                ts,
                uuid);

        if (updated > 0) {
            log.info("Updated postal address row for UUID={}", uuid);
            return;
        }

        // if update affected 0 rows -> insert
        String insertSql = "INSERT INTO DD_ACCOUNT_TBL (" +
                "DD_UUID, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, " +
                "ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE, UPDATED_TIME" +
                ") VALUES (?, ?, ?, ?, ?, ?, ?, ?)";

        jdbcTemplate.update(insertSql,
                uuid,
                adr.getStreetName(),
                adr.getHouseNumber(),
                adr.getHouseNumberAddition(),
                adr.getPostalCode(),
                adr.getCityName(),
                adr.getCountryCode(),
                ts);

        log.info("Inserted postal address row for UUID={}", uuid);
    }

    // ... keep rest of DAO methods unchanged (updateExternalIdentifier, createOuAccountingTableEntry etc.) ...
}


⸻

4) Models: verify types

You already set PostalAddressResponse fields to String (good). Ensure effectiveDate is String:

// PostalAddressResponse.java (key parts)
@JsonProperty("effectiveDate")
private String effectiveDate;

(No change required if you already did this.)

⸻

Why this should fix the issues you saw
	1.	Jackson parse error: fixed by using response.contentString() rather than response.toString() (that formerly returned a Response(...) wrapper). No more Unrecognized token 'Response'.
	2.	Timestamp parse error: effectiveDate is parsed from ISO string with Instant.parse(...) and converted to Timestamp. If parse fails we fall back to current time and log a warning — avoids Timestamp.valueOf errors.
	3.	Missing address values: we copy fallback values from the original request into the postalAddress before persisting — so fields you sent will still end up in DB even if OnePAM returned blanks.
	4.	DB failures / ORA-00942: use DD_ACCOUNT_TBL consistently; update-then-insert prevents errors when row exists or doesn’t; correct column order and parameter counts so PreparedStatement matches placeholders.
	5.	Signature mismatch: AccountingDAO.insertPostalAddress(String uuid, PostalAddressResponse adr, Timestamp effectiveTimestamp) is the single canonical signature used now.

⸻

Quick checklist to deploy
	1.	Replace OnePamRepository.createPostalAddress(...) with the snippet above.
	2.	Replace AddressService with the provided class.
	3.	Replace AccountingDAO.insertPostalAddress(...) with the provided method (and keep other existing DAO methods).
	4.	Ensure PostalAddressResponse.effectiveDate is declared as String.
	5.	Rebuild and run the batch; watch logs for:
	•	createPostalAddress response body: {...} (debug)
	•	Final address for DB insert: PostalAddressResponse(...) (info)
	•	Updated postal address row for UUID=... OR Inserted postal address row for UUID=...

⸻

If you want I can also:
	•	provide a small unit test (JUnit) that exercises the parsing and DAO upsert logic (would mock JdbcTemplate and OnePamRepository),
	•	generate a short patch/PR diff for these classes,
	•	or adapt the DAO to use MERGE (if your environment prefers MERGE statements).

Which one next?

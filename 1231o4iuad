package com.ing.datadist.api.service;

import com.ing.datadist.api.model.CofaceTableAddress;
import com.ing.datadist.api.model.CreatePostalAddressRequest;
import com.ing.datadist.api.model.CreatePostalAddressResponse;
import com.ing.datadist.api.model.PostalAddressResponse;
import com.ing.datadist.api.repository.AccountingDAO;
import com.ing.datadist.configreader.CofaceOpsConfigReader;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
@Service

@Slf4j

public class AddressService {

    private final OnePamRepository repository;

    private final AccountingDAO accountingDAO;

    private final CofaceOpsConfigReader configReader;

    public AddressService(OnePamRepository repository,

                          AccountingDAO accountingDAO,

                          CofaceOpsConfigReader configReader) {

        this.repository = repository;

        this.accountingDAO = accountingDAO;

        this.configReader = configReader;

    }

    public PostalAddressResponse createPostalAddress(String uuid, CreatePostalAddressRequest request) {

        log.info("Calling OnePAM with request={}", request);

        CreatePostalAddressResponse wrapper = repository.createPostalAddress(uuid, request).join();

        PostalAddressResponse pam = wrapper.getPostalAddress();

        log.info("Received from OnePAM postalAddress={}", pam);

        // ====== FETCH OPS DATA USING ONLY THIS METHOD ======

        Map<String, String> ops = null;

        try {

            ops = configReader.fetchAddressDetails(uuid);

            log.info("Fetched OPS address details={}", ops);

        } catch (Exception ex) {

            log.warn("No OPS address found for UUID={}, proceeding with PAM only", uuid);

        }

        // ====== MERGE PAM + OPS ======

        PostalAddressResponse merged = PostalAddressResponse.builder()

                .postalAddressUsageType(pam.getPostalAddressUsageType())

                .effectiveDate(pam.getEffectiveDate())

                .endDate(pam.getEndDate())

                .streetName(firstNonBlank(pam.getStreetName(), ops != null ? ops.get("street") : null))

                .houseNumber(pam.getHouseNumber())  // OPS does not have it

                .houseNumberAddition(pam.getHouseNumberAddition()) // OPS does not have it

                .postalCode(firstNonBlank(pam.getPostalCode(), ops != null ? ops.get("postalCode") : null))

                .cityName(firstNonBlank(pam.getCityName(), ops != null ? ops.get("city") : null))

                .countryCode(firstNonBlank(pam.getCountryCode(), ops != null ? ops.get("country") : null))

                .build();

        log.info("Merged postal address={}", merged);

        // ====== TIMESTAMP PARSE FIX ======

        Timestamp ts = null;

        try {

            ts = pam.getEffectiveDate() != null

                    ? Timestamp.from(Instant.parse(pam.getEffectiveDate()))

                    : Timestamp.from(Instant.now());

        } catch (Exception e) {

            log.warn("Invalid PAM effectiveDate format, using now()");

            ts = Timestamp.from(Instant.now());

        }

        // ====== INSERT INTO ACCOUNTING TABLE ======

        String adr
        accountingDAO.insertPostalAddress(

                uuid,
                ts,
                adr);
        adr = merged.getStreetName();
        merged.getHouseNumber(),
                merged.getHouseNumberAddition(),
                merged.getPostalCode(),
                merged.getCityName(),
                merged.getCountryCode(),

        );

        log.info("Inserted merged postal address into Accounting table for UUID={}", uuid);

        return merged;

    }

    private String firstNonBlank(String a, String b) {

        return (a != null && !a.isBlank()) ? a : b;

    }

}




    public void insertPostalAddress(String uuid, PostalAddressResponse adr, Timestamp ts) {

        if (uuid == null || uuid.isEmpty()) return;

        String eventId = "null";

        // Try UPDATE first
        String updateSql = "UPDATE DD_ACCOUNT_TBL SET " +
                "EVENT_ID = ?, " +
                "ADDR_STREET_NAME = ?, " +
                "ADDR_HOUSE_NUMBER = ?, " +
                "ADDR_BOX_NUMBER = ?, " +
                "ADDR_POSTAL_CODE = ?, " +
                "ADDR_LOCALITY_NAME = ?, " +
                "ADDR_COUNTRY_CODE = ?, " +
                "UPDATED_TIME = ? " +
                "WHERE DD_UUID = ?";

        int rows = jdbcTemplate.update(updateSql,
                eventId,
                adr.getStreetName(),
                adr.getHouseNumber(),
                adr.getHouseNumberAddition(),
                adr.getPostalCode(),
                adr.getCityName(),
                adr.getCountryCode(),
                ts,
                uuid);

        if (rows > 0) {
            log.info("Updated postal address for UUID={}", uuid);
            return;
        }

        // INSERT if no row existed
        String insertSql = "INSERT INTO DD_ACCOUNT_TBL (" +
                "DD_UUID, EVENT_ID, ADDR_STREET_NAME, ADDR_HOUSE_NUMBER, ADDR_BOX_NUMBER, " +
                "ADDR_POSTAL_CODE, ADDR_LOCALITY_NAME, ADDR_COUNTRY_CODE, UPDATED_TIME" +
                ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";

        jdbcTemplate.update(insertSql,
                uuid,
                eventId,
                adr.getStreetName(),
                adr.getHouseNumber(),
                adr.getHouseNumberAddition(),
                adr.getPostalCode(),
                adr.getCityName(),
                adr.getCountryCode(),
                ts
        );

        log.info("Inserted postal address for UUID={}", uuid);
    }
